#                                              puramente una matriz de interacción
# [multiplico para darle fuerza, pero los tipos de interacción son los mismos]
A_g_ <- A_g * 10**6
diag(A_g_) <- 0
# prepare to simulate growth
timeseries <- data.frame(matrix(dimnames = list(c(), names(x0_g)),
ncol = length(x0_g)),
check.names = FALSE)
this_timestep <- as.vector(x0_g)
timeseries[1,] <- this_timestep
# simulate growth (no ints)
i <- 0
while (sum(this_timestep) < abundF) {
this_timestep <- growth(this_timestep, abun_total = abundF, grow_step = 1)
timeseries[i,] <- this_timestep; i <- i + 1
}
timeseries$time <- 1:(i-1)
timeseries <- timeseries %>% gather(species, density, -time)
results$naive <- ggplot(data = timeseries) +
aes(x = time, y = density, colour = species) +
geom_line()
# ------------------------------------------------------------------------------
# prepare to simulate growth
timeseries <- data.frame(matrix(dimnames = list(c(), names(x0_g)),
ncol = length(x0_g)),
check.names = FALSE)
this_timestep <- as.vector(x0_g)
timeseries[1,] <- this_timestep
# simulate growth (with interactions)
i <- 0
while (sum(this_timestep) < abundF) {
this_timestep <- growth(this_timestep, abun_total = abundF, grow_step = 1, interactions = A_g_)
timeseries[i,] <- this_timestep; i <- i + 1
}
timeseries$time <- 1:(i-1)
timeseries <- timeseries %>% gather(species, density, -time)
results$naive_w_int <- ggplot(data = timeseries) +
aes(x = time, y = density, colour = species) +
geom_line()
time.end.n <- Sys.time()
times$naive_w_int <- time.end.n - time.start.n
print(paste("Time for naïve model c++:", times$naive_w_int))
## my model (logistic + groups + dependent on relative abundance) (no int)
## =============================================================================
# prepare to simulate growth
timeseries <- data.frame(matrix(dimnames = list(c(), names(x0_g)),
ncol = length(x0_g)),
check.names = FALSE)
this_timestep <- as.vector(x0_g)
timeseries[1,] <- this_timestep
groups <- factor(c(rep("group1", 8), rep("group2", 11), rep("group3", 7)))
carrying_capacities <- c(group1=8000,
group2=1100,
group3=700)[groups]
names(carrying_capacities) <- groups
i <- 0
while (sum(this_timestep) < abundF) {
this_timestep <- growth_log(x=this_timestep, carrying_capacities=carrying_capacities)
timeseries[i,] <- this_timestep; i <- i + 1
}
timeseries$time <- 1:(i-1)
timeseries <- timeseries %>% gather(species, density, -time)
results$logistic_w_probs_NO_INT <- ggplot(data = timeseries) +
aes(x = time, y = density, colour = species) +
geom_line()
time.end.n <- Sys.time()
times$logistic_w_probs_NO_INT <- time.end.n - time.start.n
print(paste("Time for growth_log (logistic_w_probs_NO_INT):", times$logistic_w_probs_NO_INT))
## logistic without stochasticity
## =============================================================================
source("~/AAA/2023-03-07__ODEs/simulateStochasticLogistic.R") # function: miaSim::simulateStochasticLogistic
groups <- factor(c(rep("group1", 8), rep("group2", 11), rep("group3", 7)))
names(groups) <- names(x0_g)
time.start.n <- Sys.time()
logsimul <- simulateStochasticLogistic(n_species = length(x0_g),
x0 = x0_g,
names_species = names(x0_g),
growth_rates = rep(1, length(x0_g)),
carrying_capacities = c(group1=8000,
group2=1100,
group3=700),
groups = groups,
# death_rates = NULL,
sigma_drift = 0, # muertes o nacimientos "extras", dist. normal:  [1] -0.091002339 -0.034060605  0.049155344 -0.012336523
sigma_epoch = 0, # same pero estacional
# sigma_external = 0,  # perturbaciones puntuales ("events"); t_external(...)
# sigma_migration = 0.002,
epoch_p = 0,
# t_external_events = NULL,
# t_external_durations = NULL,
# migration_p = 0.01,
# metacommunity_probability = NULL,
stochastic = TRUE,
error_variance = 0,
norm = FALSE,
t_end = 100)
logsimul <- logsimul$matrix %>% as.data.frame %>% gather(species, density, -time)
logsimul$group <- groups[logsimul$species]
results$logisticNODRIFT <-
ggplot(data = logsimul) +
aes(x = time, y = density, color = group, group = species) +
geom_line()
time.end.n <- Sys.time()
times$logisticNODRIFT <- time.end.n - time.start.n
print(paste("Time for logistic", times$logisticNODRIFT))
## logistic without stochasticity
## =============================================================================
time.start.n <- Sys.time()
logsimul <- simulateStochasticLogistic(n_species = length(x0_g),
x0 = x0_g,
names_species = names(x0_g),
growth_rates = rep(1, length(x0_g)),
carrying_capacities = c(group1=8000,
group2=1100,
group3=700),
groups = groups,
# death_rates = NULL,
sigma_drift = 0.01, # muertes o nacimientos "extras", dist. normal:  [1] -0.091002339 -0.034060605  0.049155344 -0.012336523
sigma_epoch = 0  ,   # same pero estacional
# sigma_external = 0,  # perturbaciones puntuales ("events"); t_external(...)
# sigma_migration = 0.002,
epoch_p = 0,
# t_external_events = NULL,
# t_external_durations = NULL,
# migration_p = 0.01,
# metacommunity_probability = NULL,
stochastic = TRUE,
error_variance = 0,
norm = FALSE,
t_end = 1000)
logsimul_ <- logsimul$matrix %>% as.data.frame %>% gather(species, density, -time)
logsimul_$group <- groups[logsimul_$species]
results$logisticDRIFT <-
ggplot(data = logsimul_) +
aes(x = time, y = density, color = group, group = species) +
geom_line()
time.end.n <- Sys.time()
times$logisticDRIFT <- time.end.n - time.start.n
print(paste("Time for logistic w/drift", times$logisticDRIFT))
results
times
results$logisticDRIFT <-
ggplot(data = logsimul_) +
aes(x = time, y = density, color = group, group = species) +
geom_line() + labs(title="logisticDRIFT")
results$logisticDRIFT
## naïve::    prob == r + ((interactions %*% Vabund(rel)); <-- esto es la probabilidad, así que la curva
##                                                         es x · prob = dxdt --> x·r + x·A(?). EQUIVALENTE A gLV
##                                                         la diagonal de la matriz A es 1, porque la probabilidad
##                                                         xii es exactamente igual a la abundancia relativa de i [Vabund(i), xi]
##            Vabund(rel) + ((interactions %*% Vabund(rel)) <-- lo mismo pero la diagonal de la matriz A es 0 y el peso de la abund rel
##                                                          lo metemos aparte. Así está en el código.
##
##
## gLV::      dxdt <- x * (r + A %*% x)   <-- x·r + A·x²
##            (en vez de x * podemos poner la matriz de diag == x)
##
##
##
## por qué dropeé el gLV
## =====================
## L
## -----
## porque no me gusta como "incluye" la carrying capacity L.
## gLV es una modificación del logistic model for growth: en forma de valores negativos en la diagonal
## (== cada especie tiene un carrying capacity, inversamente proporcional a su abundancia; cada especie
## es "competidora" de sí misma). Pero esta forma de formularlo nos impide predefinir la abundancia final deseada...
## - en el naïve sí se define con un simple "while", ya que es un modelo mecanístico.
##
## deriva
## ------
## porque el gLV no tiene deriva
## DIFERENCIAS: "prob" del naïve es una probabilidad, no un rate fijo. De ahí que aparezca deriva
## en el logístico estocástico SÍ se puede incluir
## Datos y params
## =============================================================================
source("~/AAA/2023-03-07__ODEs/functions_gLV.R") # function: my_randomA
df <- data.table::fread("~/AAA/OTU_data/all_transfers_table_glc.txt", skip = 1)
# map <- data.table::fread("~/AAA/data/map_glc_ALL.csv")
orig <-"sa10"
final<-"sa67"
otus <- df$`#OTU ID`
df$`#OTU ID` <- NULL
df$taxonomy  <- NULL
set.seed(303)
# abundancias iniciales (ABSOLUTAS)
x0_g <- df[[orig]]#/sum(df[[orig]])
xF_g <- df[[final]]#/sum(df[[final]])
abundF <- sum(xF_g)
names(x0_g) <- otus
names(xF_g) <- otus
x0_g <- x0_g[x0_g!=0]
xF_g <- xF_g[xF_g!=0]
x0_g <- sort(x0_g, decreasing = TRUE)[2:length(x0_g)] # [1:length(x0_g)] ---> no filter
xF_g <- sort(xF_g, decreasing = TRUE)[2:length(xF_g)] # [1:length(x0_g)] ---> no filter
# interacciones
A_g <- myrandomA(
n_species = length(x0_g),
names_species = names(x0_g),
diagonal = -0.002,
scale_off_diagonal = 1,
connectance = 0.2,
mutualism = 0.75, commensalism = 1, competition = 0.5,
parasitism = 0, amensalism = 0,
symmetric = FALSE,
interactions = NULL)
# growth rates
r_g <- runif(length(x0_g))
# empty list
results <- list()
times <- list()
## naïve model
## =============================================================================
# /home/silviatm/R-4.0.5/bin/Rscript $workdir/v3.R \
# -a $workdir/'$ABUNTABLE' -s '$sa' \
# --dilution '$DILUTIONFACTOR' --no_of_dil '$NO_OF_TRANSFERS' --no_of_simulations '$NO_OF_SIMULATIONS' --subset "'$Leaves'" \
# --fixation_at '$FIXATION_THRESHOLD' --fix_percentage TRUE --perc '$Average' \
# --outputname '$Core'_X'$sa' --outdir $workdir/'$OUTPUTPREFIX''$sa' --cores 16
library("untb")
library("tidyverse")
library("dilgrowth")
# Negative probabilities not allowed !!!!!!!!!
# (1) prob = x * A, siendo diag(A) = 1;    --> retirar TODAS las inter negativas
# (2) prob = x + x * A, siendo diag(A) = 0 --> puedo tener inter - y solo después
#                                              de sumar "x" y "x * A" quitarlas
#                                          --> al contrario que en gLV, A sí es
#                                              puramente una matriz de interacción
# [multiplico para darle fuerza, pero los tipos de interacción son los mismos]
A_g_ <- A_g * 10**6
diag(A_g_) <- 0
# prepare to simulate growth
timeseries <- data.frame(matrix(dimnames = list(c(), names(x0_g)),
ncol = length(x0_g)),
check.names = FALSE)
this_timestep <- as.vector(x0_g)
timeseries[1,] <- this_timestep
# simulate growth (no ints)
i <- 0
while (sum(this_timestep) < abundF) {
this_timestep <- growth(this_timestep, abun_total = abundF, grow_step = 1)
timeseries[i,] <- this_timestep; i <- i + 1
}
timeseries$time <- 1:(i-1)
timeseries <- timeseries %>% gather(species, density, -time)
results$naive <- ggplot(data = timeseries) +
aes(x = time, y = density, colour = species) +
geom_line() + labs(title="naive")
# ------------------------------------------------------------------------------
# prepare to simulate growth
timeseries <- data.frame(matrix(dimnames = list(c(), names(x0_g)),
ncol = length(x0_g)),
check.names = FALSE)
this_timestep <- as.vector(x0_g)
timeseries[1,] <- this_timestep
# simulate growth (with interactions)
i <- 0
while (sum(this_timestep) < abundF) {
this_timestep <- growth(this_timestep, abun_total = abundF, grow_step = 1, interactions = A_g_)
timeseries[i,] <- this_timestep; i <- i + 1
}
timeseries$time <- 1:(i-1)
timeseries <- timeseries %>% gather(species, density, -time)
results$naive_w_int <- ggplot(data = timeseries) +
aes(x = time, y = density, colour = species) +
geom_line() + labs(title="naive_w_int")
time.end.n <- Sys.time()
times$naive_w_int <- time.end.n - time.start.n
print(paste("Time for naïve model c++:", times$naive_w_int))
## my model (logistic + groups + dependent on relative abundance) (no int)
## =============================================================================
# prepare to simulate growth
timeseries <- data.frame(matrix(dimnames = list(c(), names(x0_g)),
ncol = length(x0_g)),
check.names = FALSE)
this_timestep <- as.vector(x0_g)
timeseries[1,] <- this_timestep
groups <- factor(c(rep("group1", 8), rep("group2", 11), rep("group3", 7)))
carrying_capacities <- c(group1=8000,
group2=1100,
group3=700)[groups]
names(carrying_capacities) <- groups
i <- 0
while (sum(this_timestep) < abundF) {
this_timestep <- growth_log(x=this_timestep, carrying_capacities=carrying_capacities)
timeseries[i,] <- this_timestep; i <- i + 1
}
timeseries$time <- 1:(i-1)
timeseries <- timeseries %>% gather(species, density, -time)
results$logistic_w_probs_NO_INT <- ggplot(data = timeseries) +
aes(x = time, y = density, colour = species) +
geom_line() + labs(title="logistic_w_probs_NO_INT")
time.end.n <- Sys.time()
times$logistic_w_probs_NO_INT <- time.end.n - time.start.n
print(paste("Time for growth_log (logistic_w_probs_NO_INT):", times$logistic_w_probs_NO_INT))
## logistic without stochasticity
## =============================================================================
source("~/AAA/2023-03-07__ODEs/simulateStochasticLogistic.R") # function: miaSim::simulateStochasticLogistic
groups <- factor(c(rep("group1", 8), rep("group2", 11), rep("group3", 7)))
names(groups) <- names(x0_g)
time.start.n <- Sys.time()
logsimul <- simulateStochasticLogistic(n_species = length(x0_g),
x0 = x0_g,
names_species = names(x0_g),
growth_rates = rep(1, length(x0_g)),
carrying_capacities = c(group1=8000,
group2=1100,
group3=700),
groups = groups,
# death_rates = NULL,
sigma_drift = 0, # muertes o nacimientos "extras", dist. normal:  [1] -0.091002339 -0.034060605  0.049155344 -0.012336523
sigma_epoch = 0, # same pero estacional
# sigma_external = 0,  # perturbaciones puntuales ("events"); t_external(...)
# sigma_migration = 0.002,
epoch_p = 0,
# t_external_events = NULL,
# t_external_durations = NULL,
# migration_p = 0.01,
# metacommunity_probability = NULL,
stochastic = TRUE,
error_variance = 0,
norm = FALSE,
t_end = 100)
logsimul <- logsimul$matrix %>% as.data.frame %>% gather(species, density, -time)
logsimul$group <- groups[logsimul$species]
results$logisticNODRIFT <-
ggplot(data = logsimul) +
aes(x = time, y = density, color = group, group = species) +
geom_line() + labs(title="logisticNODRIFT")
time.end.n <- Sys.time()
times$logisticNODRIFT <- time.end.n - time.start.n
print(paste("Time for logistic", times$logisticNODRIFT))
## logistic without stochasticity
## =============================================================================
time.start.n <- Sys.time()
logsimul <- simulateStochasticLogistic(n_species = length(x0_g),
x0 = x0_g,
names_species = names(x0_g),
growth_rates = rep(1, length(x0_g)),
carrying_capacities = c(group1=8000,
group2=1100,
group3=700),
groups = groups,
# death_rates = NULL,
sigma_drift = 0.01, # muertes o nacimientos "extras", dist. normal:  [1] -0.091002339 -0.034060605  0.049155344 -0.012336523
sigma_epoch = 0  ,   # same pero estacional
# sigma_external = 0,  # perturbaciones puntuales ("events"); t_external(...)
# sigma_migration = 0.002,
epoch_p = 0,
# t_external_events = NULL,
# t_external_durations = NULL,
# migration_p = 0.01,
# metacommunity_probability = NULL,
stochastic = TRUE,
error_variance = 0,
norm = FALSE,
t_end = 1000)
logsimul_ <- logsimul$matrix %>% as.data.frame %>% gather(species, density, -time)
logsimul_$group <- groups[logsimul_$species]
results$logisticDRIFT <-
ggplot(data = logsimul_) +
aes(x = time, y = density, color = group, group = species) +
geom_line() + labs(title="logisticDRIFT")
time.end.n <- Sys.time()
times$logisticDRIFT <- time.end.n - time.start.n
print(paste("Time for logistic w/drift", times$logisticDRIFT))
results
groups
x0_g
x0_g/sum(x0_g)
A_g
View(A_g)
max(A_g)
min(A_g)
x0_g %*% A_g
x0_g %*% A_g_
clear()
x0_g %*% A_g_
View(A_g_)
max(A_g_)
min(A_g_)
(x0_g/sum(x0_g)) %*% A_g_
x0_g/sum(x0_g)
groups
carrying_capacities
setwd("~/repos/predicting_fixation/2_generate_training_data")
load()
load(".Rhistory")
library(stringr)
library(tidyverse)
library(gridExtra)
library(parallel)
library(optparse)
library(vegan) # shannon + pielou custom function
library(DescTools) # gini
library(data.table)
parser <- OptionParser(option_list = list(
make_option(c("-i", "--input"), type="character", default=NULL),
make_option(c("-n", "--numsamples"), type="integer", default=NULL),
make_option(c("-p", "--pcgtable"), type="character", default=NULL)
)
); opt <- parse_args(parser)
## Data ########################################################################
# The following lines define some simulation parameters, such as the fixation
# threshold, the portion of simulations to be checked for fixation, and the
# number of cores to be used. It also defines the output folder and the output
# name based on the input directory and the fixation threshold.
cores <- 16
fixation_threshold <- 0.5
percN <- 0.95 # portion of simulations we're going to check for fixation
## output
output_folder <- paste0("processed_data_simcomms_", fixation_threshold)
output_name <- paste0("RESULT_", basename(opt$input))
opt$input="../1_datasets/simcomms/lognorm_10"
opt$input="../1_datasets/simcomms/lognorm_10sp_size1e+06.tsv"
opt$help
opt$numsamples=9
opt$input="test_data/SIMCOMM_SIMS_0.01_lognorm_1e+06_sp_10_1/"
opt$pcgtable="../1_datasets/PCGtables/EvenGroups_N3_10sp.csv"
## Data ########################################################################
# The following lines define some simulation parameters, such as the fixation
# threshold, the portion of simulations to be checked for fixation, and the
# number of cores to be used. It also defines the output folder and the output
# name based on the input directory and the fixation threshold.
cores <- 8
fixation_threshold <- 0.5
percN <- 0.95 # portion of simulations we're going to check for fixation
## output
output_folder <- paste0("processed_data_simcomms_", fixation_threshold)
output_name <- paste0("RESULT_", basename(opt$input))
## input
simuls_folder  <- opt$input
num_of_samples <- opt$numsamples
pcgtable       <- opt$pcgtable
if (is.null(num_of_samples)) {
stop("You must specify the number of samples")
}
## Functions ###################################################################
source("simul_fixation_functions.R")
read_simul_data <- function(simuls_folder, num_of_samples) {
filenames <- c()
for (samplenum in 1:num_of_samples) {
filenames <- c(filenames, list.files(path = paste0(simuls_folder, samplenum),
pattern = "*.csv",
recursive = TRUE,
full.names = TRUE)
)
}
simul_data <- mapply(filenames, FUN=function(full_name) {
last_dir <- tail(strsplit(dirname(full_name), "/")[[1]], 1)
name  <- paste(last_dir, basename(full_name), sep = "/")
name  <- str_sub(name, end=-5) # remove ".csv"
split <- str_split(name, "_")[[1]]
return(list(
"distrib" = split[4],
"size" = split[5],
"richness" = split[7],
"transfer" = as.numeric(split[11]),
"dilfactor" = as.numeric(split[3]),
"filename" = full_name,
"sample" = paste(str_split(split[8], "/")[[1]][1],
split[4], split[5], split[7], sep = "_")
))
}) %>% t %>% as_tibble()
}
record_fixation <- function(processed_data) {
reached_fixation_at <- which((processed_data$perc_N %>% as.numeric)>0.9)[1]
return(reached_fixation_at)
}
## Load all data and metadata ##################################################
options(scipen=10)
simul_data <- read_simul_data(simuls_folder, num_of_samples)
message(paste0("Read data!
----------
nrow>> ", nrow(simul_data), "
ncol>> ", ncol(simul_data),"
colnames>> ", paste(colnames(simul_data), collapse=', '), "
dilution factors>> ", paste(unique(simul_data$dilfactor), collapse=', '),"
community sizes >> ", paste(unique(simul_data$size), collapse=', '),"
samples>> ", paste(unique(simul_data$sample), collapse = ', ')))
simul_data
simuls_folder
num_of_samples
opt$input
opt$input="test_data/SIMCOMM_SIMS_0.01_lognorm_1e+06_sp_10_"
simuls_folder="test_data/SIMCOMM_SIMS_0.01_lognorm_1e+06_sp_10_"
simul_data <- read_simul_data(simuls_folder, num_of_samples)
message(paste0("Read data!
----------
nrow>> ", nrow(simul_data), "
ncol>> ", ncol(simul_data),"
colnames>> ", paste(colnames(simul_data), collapse=', '), "
dilution factors>> ", paste(unique(simul_data$dilfactor), collapse=', '),"
community sizes >> ", paste(unique(simul_data$size), collapse=', '),"
samples>> ", paste(unique(simul_data$sample), collapse = ', ')))
if (!file.exists(output_folder)) {system(paste("mkdir -p", output_folder))}
if (!is.null(pcgtable)) {
pcg_info <- fread(pcgtable)
pcg_info <- pcg_info[1:(nrow(pcg_info)-1), ]
}
# processed_data + sample_info #################################################
################################################################################
metadata <- simul_data[order(as.numeric(simul_data$transfer)),] # ordered by transfer
message("creating 'processed_data'...") # DEBUG
all_processed_data <- list() # for plots [4] onwards
for (sa in unique(metadata$sample)) {
# "all_processed_data":  fixated + perc + size
all_processed_data[[sa]] <- create_processed_data(metadata[metadata$sample==sa,],
fixation_threshold,cores=cores,
pcgtable = pcg_info)
all_processed_data[[sa]] <- arrange(all_processed_data[[sa]]) # importante ordenar
}
save.image("test.RData")
